import{am as B,ax as X,ay as J,az as Z,aA as U,aB as q,aC as v,aD as $,aE as Q,aF as P,aG as ee,at as se,aH as te,aI as ne,as as ie,aJ as re,aK as oe,aL as ae,aM as ce,aN as le}from"./index.83ee0ec4.js";class Y{constructor(){this.pluginCallbacks=[],this.register(function(e){return new me(e)}),this.register(function(e){return new Ee(e)}),this.register(function(e){return new Me(e)}),this.register(function(e){return new Ie(e)}),this.register(function(e){return new Ae(e)}),this.register(function(e){return new we(e)}),this.register(function(e){return new ye(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,n,s){typeof n=="object"&&(console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."),s=n);const r=new Te,i=[];for(let o=0,a=this.pluginCallbacks.length;o<a;o++)i.push(this.pluginCallbacks[o](r));r.setPlugins(i),r.write(e,t,s).catch(n)}parseAsync(e,t){const n=this;return new Promise(function(s,r){n.parse(e,s,r,t)})}}const g={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},A={};A[se]=g.NEAREST;A[te]=g.NEAREST_MIPMAP_NEAREST;A[ne]=g.NEAREST_MIPMAP_LINEAR;A[ie]=g.LINEAR;A[re]=g.LINEAR_MIPMAP_NEAREST;A[oe]=g.LINEAR_MIPMAP_LINEAR;A[ae]=g.CLAMP_TO_EDGE;A[ce]=g.REPEAT;A[le]=g.MIRRORED_REPEAT;const k={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},z=12,ue=1179937895,fe=2,H=8,he=1313821514,pe=5130562;function S(c,e){return c.length===e.length&&c.every(function(t,n){return t===e[n]})}function de(c){return new TextEncoder().encode(c).buffer}function ge(c){return S(c.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function xe(c,e,t){const n={min:new Array(c.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(c.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let s=e;s<e+t;s++)for(let r=0;r<c.itemSize;r++){let i;c.itemSize>4?i=c.array[s*c.itemSize+r]:r===0?i=c.getX(s):r===1?i=c.getY(s):r===2?i=c.getZ(s):r===3&&(i=c.getW(s)),n.min[r]=Math.min(n.min[r],i),n.max[r]=Math.max(n.max[r],i)}return n}function K(c){return Math.ceil(c/4)*4}function G(c,e=0){const t=K(c.byteLength);if(t!==c.byteLength){const n=new Uint8Array(t);if(n.set(new Uint8Array(c)),e!==0)for(let s=c.byteLength;s<t;s++)n[s]=e;return n.buffer}return c}let L=null;function V(){return L||(typeof document=="undefined"&&typeof OffscreenCanvas!="undefined"?L=new OffscreenCanvas(1,1):L=document.createElement("canvas"),L)}function j(c,e){if(c.toBlob!==void 0)return new Promise(n=>c.toBlob(n,e));let t;return e==="image/jpeg"?t=.92:e==="image/webp"&&(t=.8),c.convertToBlob({type:e,quality:t})}class Te{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,t,n){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},n),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const s=this,r=s.buffers,i=s.json;n=s.options;const o=s.extensionsUsed,a=new Blob(r,{type:"application/octet-stream"}),f=Object.keys(o);if(f.length>0&&(i.extensionsUsed=f),i.buffers&&i.buffers.length>0&&(i.buffers[0].byteLength=a.size),n.binary===!0){const h=new FileReader;h.readAsArrayBuffer(a),h.onloadend=function(){const l=G(h.result),x=new DataView(new ArrayBuffer(H));x.setUint32(0,l.byteLength,!0),x.setUint32(4,pe,!0);const u=G(de(JSON.stringify(i)),32),d=new DataView(new ArrayBuffer(H));d.setUint32(0,u.byteLength,!0),d.setUint32(4,he,!0);const T=new ArrayBuffer(z),E=new DataView(T);E.setUint32(0,ue,!0),E.setUint32(4,fe,!0);const m=z+d.byteLength+u.byteLength+x.byteLength+l.byteLength;E.setUint32(8,m,!0);const _=new Blob([T,d,u,x,l],{type:"application/octet-stream"}),p=new FileReader;p.readAsArrayBuffer(_),p.onloadend=function(){t(p.result)}}}else if(i.buffers&&i.buffers.length>0){const h=new FileReader;h.readAsDataURL(a),h.onloadend=function(){const l=h.result;i.buffers[0].uri=l,t(i)}}else t(i)}serializeUserData(e,t){if(Object.keys(e.userData).length===0)return;const n=this.options,s=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(n.includeCustomExtensions&&r.gltfExtensions){t.extensions===void 0&&(t.extensions={});for(const i in r.gltfExtensions)t.extensions[i]=r.gltfExtensions[i],s[i]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(t.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,t=!1){if(this.uids.has(e)===!1){const s=new Map;s.set(!0,this.uid++),s.set(!1,this.uid++),this.uids.set(e,s)}return this.uids.get(e).get(t)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const n=new B;for(let s=0,r=e.count;s<r;s++)if(Math.abs(n.fromBufferAttribute(e,s).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const t=this.cache;if(t.attributesNormalized.has(e))return t.attributesNormalized.get(e);const n=e.clone(),s=new B;for(let r=0,i=n.count;r<i;r++)s.fromBufferAttribute(n,r),s.x===0&&s.y===0&&s.z===0?s.setX(1):s.normalize(),n.setXYZ(r,s.x,s.y,s.z);return t.attributesNormalized.set(e,n),n}applyTextureTransform(e,t){let n=!1;const s={};(t.offset.x!==0||t.offset.y!==0)&&(s.offset=t.offset.toArray(),n=!0),t.rotation!==0&&(s.rotation=t.rotation,n=!0),(t.repeat.x!==1||t.repeat.y!==1)&&(s.scale=t.repeat.toArray(),n=!0),n&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=s,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,t){if(e===t)return e;console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");const n=e==null?void 0:e.image,s=t==null?void 0:t.image,r=Math.max((n==null?void 0:n.width)||0,(s==null?void 0:s.width)||0),i=Math.max((n==null?void 0:n.height)||0,(s==null?void 0:s.height)||0),o=V();o.width=r,o.height=i;const a=o.getContext("2d");a.fillStyle="#00ffff",a.fillRect(0,0,r,i);const f=a.getImageData(0,0,r,i);if(n){a.drawImage(n,0,0,r,i);const x=a.getImageData(0,0,r,i).data;for(let u=2;u<x.length;u+=4)f.data[u]=x[u]}if(s){a.drawImage(s,0,0,r,i);const x=a.getImageData(0,0,r,i).data;for(let u=1;u<x.length;u+=4)f.data[u]=x[u]}a.putImageData(f,0,0);const l=(e||t).clone();return l.source=new X(o),l}processBuffer(e){const t=this.json,n=this.buffers;return t.buffers||(t.buffers=[{byteLength:0}]),n.push(e),0}processBufferView(e,t,n,s,r){const i=this.json;i.bufferViews||(i.bufferViews=[]);let o;t===g.UNSIGNED_BYTE?o=1:t===g.UNSIGNED_SHORT?o=2:o=4;const a=K(s*e.itemSize*o),f=new DataView(new ArrayBuffer(a));let h=0;for(let u=n;u<n+s;u++)for(let d=0;d<e.itemSize;d++){let T;e.itemSize>4?T=e.array[u*e.itemSize+d]:d===0?T=e.getX(u):d===1?T=e.getY(u):d===2?T=e.getZ(u):d===3&&(T=e.getW(u)),t===g.FLOAT?f.setFloat32(h,T,!0):t===g.UNSIGNED_INT?f.setUint32(h,T,!0):t===g.UNSIGNED_SHORT?f.setUint16(h,T,!0):t===g.UNSIGNED_BYTE&&f.setUint8(h,T),h+=o}const l={buffer:this.processBuffer(f.buffer),byteOffset:this.byteOffset,byteLength:a};return r!==void 0&&(l.target=r),r===g.ARRAY_BUFFER&&(l.byteStride=e.itemSize*o),this.byteOffset+=a,i.bufferViews.push(l),{id:i.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const t=this,n=t.json;return n.bufferViews||(n.bufferViews=[]),new Promise(function(s){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const i=G(r.result),o={buffer:t.processBuffer(i),byteOffset:t.byteOffset,byteLength:i.byteLength};t.byteOffset+=i.byteLength,s(n.bufferViews.push(o)-1)}})}processAccessor(e,t,n,s){const r=this.options,i=this.json,o={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=g.FLOAT;else if(e.array.constructor===Uint32Array)a=g.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)a=g.UNSIGNED_SHORT;else if(e.array.constructor===Uint8Array)a=g.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");if(n===void 0&&(n=0),s===void 0&&(s=e.count),r.truncateDrawRange&&t!==void 0&&t.index===null){const u=n+s,d=t.drawRange.count===1/0?e.count:t.drawRange.start+t.drawRange.count;n=Math.max(n,t.drawRange.start),s=Math.min(u,d)-n,s<0&&(s=0)}if(s===0)return null;const f=xe(e,n,s);let h;t!==void 0&&(h=e===t.index?g.ELEMENT_ARRAY_BUFFER:g.ARRAY_BUFFER);const l=this.processBufferView(e,a,n,s,h),x={bufferView:l.id,byteOffset:l.byteOffset,componentType:a,count:s,max:f.max,min:f.min,type:o[e.itemSize]};return e.normalized===!0&&(x.normalized=!0),i.accessors||(i.accessors=[]),i.accessors.push(x)-1}processImage(e,t,n,s="image/png"){const r=this,i=r.cache,o=r.json,a=r.options,f=r.pending;i.images.has(e)||i.images.set(e,{});const h=i.images.get(e),l=s+":flipY/"+n.toString();if(h[l]!==void 0)return h[l];o.images||(o.images=[]);const x={mimeType:s},u=V();u.width=Math.min(e.width,a.maxTextureSize),u.height=Math.min(e.height,a.maxTextureSize);const d=u.getContext("2d");if(n===!0&&(d.translate(0,u.height),d.scale(1,-1)),e.data!==void 0){t!==J&&console.error("GLTFExporter: Only RGBAFormat is supported."),(e.width>a.maxTextureSize||e.height>a.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const E=new Uint8ClampedArray(e.height*e.width*4);for(let m=0;m<E.length;m+=4)E[m+0]=e.data[m+0],E[m+1]=e.data[m+1],E[m+2]=e.data[m+2],E[m+3]=e.data[m+3];d.putImageData(new ImageData(E,e.width,e.height),0,0)}else d.drawImage(e,0,0,u.width,u.height);a.binary===!0?f.push(j(u,s).then(E=>r.processBufferViewImage(E)).then(E=>{x.bufferView=E})):u.toDataURL!==void 0?x.uri=u.toDataURL(s):f.push(j(u,s).then(E=>new FileReader().readAsDataURL(E)).then(E=>{x.uri=E}));const T=o.images.push(x)-1;return h[l]=T,T}processSampler(e){const t=this.json;t.samplers||(t.samplers=[]);const n={magFilter:A[e.magFilter],minFilter:A[e.minFilter],wrapS:A[e.wrapS],wrapT:A[e.wrapT]};return t.samplers.push(n)-1}processTexture(e){const t=this.cache,n=this.json;if(t.textures.has(e))return t.textures.get(e);n.textures||(n.textures=[]);let s=e.userData.mimeType;s==="image/webp"&&(s="image/png");const r={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,s)};e.name&&(r.name=e.name),this._invokeAll(function(o){o.writeTexture&&o.writeTexture(e,r)});const i=n.textures.push(r)-1;return t.textures.set(e,i),i}processMaterial(e){const t=this.cache,n=this.json;if(t.materials.has(e))return t.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;n.materials||(n.materials=[]);const s={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(S(r,[1,1,1,1])||(s.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(s.pbrMetallicRoughness.metallicFactor=e.metalness,s.pbrMetallicRoughness.roughnessFactor=e.roughness):(s.pbrMetallicRoughness.metallicFactor=.5,s.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const o=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),a={index:this.processTexture(o)};this.applyTextureTransform(a,o),s.pbrMetallicRoughness.metallicRoughnessTexture=a}if(e.map){const o={index:this.processTexture(e.map)};this.applyTextureTransform(o,e.map),s.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive.clone().multiplyScalar(e.emissiveIntensity),a=Math.max(o.r,o.g,o.b);if(a>1&&(o.multiplyScalar(1/a),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),a>0&&(s.emissiveFactor=o.toArray()),e.emissiveMap){const f={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(f,e.emissiveMap),s.emissiveTexture=f}}if(e.normalMap){const o={index:this.processTexture(e.normalMap)};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),s.normalTexture=o}if(e.aoMap){const o={index:this.processTexture(e.aoMap),texCoord:1};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),s.occlusionTexture=o}e.transparent?s.alphaMode="BLEND":e.alphaTest>0&&(s.alphaMode="MASK",s.alphaCutoff=e.alphaTest),e.side===Z&&(s.doubleSided=!0),e.name!==""&&(s.name=e.name),this.serializeUserData(e,s),this._invokeAll(function(o){o.writeMaterial&&o.writeMaterial(e,s)});const i=n.materials.push(s)-1;return t.materials.set(e,i),i}processMesh(e){const t=this.cache,n=this.json,s=[e.geometry.uuid];if(Array.isArray(e.material))for(let p=0,M=e.material.length;p<M;p++)s.push(e.material[p].uuid);else s.push(e.material.uuid);const r=s.join(":");if(t.meshes.has(r))return t.meshes.get(r);const i=e.geometry;let o;if(e.isLineSegments?o=g.LINES:e.isLineLoop?o=g.LINE_LOOP:e.isLine?o=g.LINE_STRIP:e.isPoints?o=g.POINTS:o=e.material.wireframe?g.LINES:g.TRIANGLES,i.isBufferGeometry!==!0)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const a={},f={},h=[],l=[],x={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},u=i.getAttribute("normal");u!==void 0&&!this.isNormalizedNormalAttribute(u)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),i.setAttribute("normal",this.createNormalizedNormalAttribute(u)));let d=null;for(let p in i.attributes){if(p.slice(0,5)==="morph")continue;const M=i.attributes[p];if(p=x[p]||p.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(p)||(p="_"+p),t.attributes.has(this.getUID(M))){f[p]=t.attributes.get(this.getUID(M));continue}d=null;const w=M.array;p==="JOINTS_0"&&!(w instanceof Uint16Array)&&!(w instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),d=new U(new Uint16Array(w),M.itemSize,M.normalized));const I=this.processAccessor(d||M,i);I!==null&&(f[p]=I,t.attributes.set(this.getUID(M),I))}if(u!==void 0&&i.setAttribute("normal",u),Object.keys(f).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const p=[],M=[],y={};if(e.morphTargetDictionary!==void 0)for(const w in e.morphTargetDictionary)y[e.morphTargetDictionary[w]]=w;for(let w=0;w<e.morphTargetInfluences.length;++w){const I={};let O=!1;for(const b in i.morphAttributes){if(b!=="position"&&b!=="normal"){O||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),O=!0);continue}const N=i.morphAttributes[b][w],C=b.toUpperCase(),F=i.attributes[b];if(t.attributes.has(this.getUID(N,!0))){I[C]=t.attributes.get(this.getUID(N,!0));continue}const D=N.clone();if(!i.morphTargetsRelative)for(let R=0,W=N.count;R<W;R++)D.setXYZ(R,N.getX(R)-F.getX(R),N.getY(R)-F.getY(R),N.getZ(R)-F.getZ(R));I[C]=this.processAccessor(D,i),t.attributes.set(this.getUID(F,!0),I[C])}l.push(I),p.push(e.morphTargetInfluences[w]),e.morphTargetDictionary!==void 0&&M.push(y[w])}a.weights=p,M.length>0&&(a.extras={},a.extras.targetNames=M)}const T=Array.isArray(e.material);if(T&&i.groups.length===0)return null;const E=T?e.material:[e.material],m=T?i.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let p=0,M=m.length;p<M;p++){const y={mode:o,attributes:f};if(this.serializeUserData(i,y),l.length>0&&(y.targets=l),i.index!==null){let I=this.getUID(i.index);(m[p].start!==void 0||m[p].count!==void 0)&&(I+=":"+m[p].start+":"+m[p].count),t.attributes.has(I)?y.indices=t.attributes.get(I):(y.indices=this.processAccessor(i.index,i,m[p].start,m[p].count),t.attributes.set(I,y.indices)),y.indices===null&&delete y.indices}const w=this.processMaterial(E[m[p].materialIndex]);w!==null&&(y.material=w),h.push(y)}a.primitives=h,n.meshes||(n.meshes=[]),this._invokeAll(function(p){p.writeMesh&&p.writeMesh(e,a)});const _=n.meshes.push(a)-1;return t.meshes.set(r,_),_}processCamera(e){const t=this.json;t.cameras||(t.cameras=[]);const n=e.isOrthographicCamera,s={type:n?"orthographic":"perspective"};return n?s.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:s.perspective={aspectRatio:e.aspect,yfov:q.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(s.name=e.type),t.cameras.push(s)-1}processAnimation(e,t){const n=this.json,s=this.nodeMap;n.animations||(n.animations=[]),e=Y.Utils.mergeMorphTargetTracks(e.clone(),t);const r=e.tracks,i=[],o=[];for(let a=0;a<r.length;++a){const f=r[a],h=v.parseTrackName(f.name);let l=v.findNode(t,h.nodeName);const x=k[h.propertyName];if(h.objectName==="bones"&&(l.isSkinnedMesh===!0?l=l.skeleton.getBoneByName(h.objectIndex):l=void 0),!l||!x)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',f.name),null;const u=1;let d=f.values.length/f.times.length;x===k.morphTargetInfluences&&(d/=l.morphTargetInfluences.length);let T;f.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(T="CUBICSPLINE",d/=3):f.getInterpolation()===$?T="STEP":T="LINEAR",o.push({input:this.processAccessor(new U(f.times,u)),output:this.processAccessor(new U(f.values,d)),interpolation:T}),i.push({sampler:o.length-1,target:{node:s.get(l),path:x}})}return n.animations.push({name:e.name||"clip_"+n.animations.length,samplers:o,channels:i}),n.animations.length-1}processSkin(e){const t=this.json,n=this.nodeMap,s=t.nodes[n.get(e)],r=e.skeleton;if(r===void 0)return null;const i=e.skeleton.bones[0];if(i===void 0)return null;const o=[],a=new Float32Array(r.bones.length*16),f=new Q;for(let l=0;l<r.bones.length;++l)o.push(n.get(r.bones[l])),f.copy(r.boneInverses[l]),f.multiply(e.bindMatrix).toArray(a,l*16);return t.skins===void 0&&(t.skins=[]),t.skins.push({inverseBindMatrices:this.processAccessor(new U(a,16)),joints:o,skeleton:n.get(i)}),s.skin=t.skins.length-1}processNode(e){const t=this.json,n=this.options,s=this.nodeMap;t.nodes||(t.nodes=[]);const r={};if(n.trs){const o=e.quaternion.toArray(),a=e.position.toArray(),f=e.scale.toArray();S(o,[0,0,0,1])||(r.rotation=o),S(a,[0,0,0])||(r.translation=a),S(f,[1,1,1])||(r.scale=f)}else e.matrixAutoUpdate&&e.updateMatrix(),ge(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const o=this.processMesh(e);o!==null&&(r.mesh=o)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const o=[];for(let a=0,f=e.children.length;a<f;a++){const h=e.children[a];if(h.visible||n.onlyVisible===!1){const l=this.processNode(h);l!==null&&o.push(l)}}o.length>0&&(r.children=o)}this._invokeAll(function(o){o.writeNode&&o.writeNode(e,r)});const i=t.nodes.push(r)-1;return s.set(e,i),i}processScene(e){const t=this.json,n=this.options;t.scenes||(t.scenes=[],t.scene=0);const s={};e.name!==""&&(s.name=e.name),t.scenes.push(s);const r=[];for(let i=0,o=e.children.length;i<o;i++){const a=e.children[i];if(a.visible||n.onlyVisible===!1){const f=this.processNode(a);f!==null&&r.push(f)}}r.length>0&&(s.nodes=r),this.serializeUserData(e,s)}processObjects(e){const t=new P;t.name="AuxScene";for(let n=0;n<e.length;n++)t.children.push(e[n]);this.processScene(t)}processInput(e){const t=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(s){s.beforeParse&&s.beforeParse(e)});const n=[];for(let s=0;s<e.length;s++)e[s]instanceof P?this.processScene(e[s]):n.push(e[s]);n.length>0&&this.processObjects(n);for(let s=0;s<this.skins.length;++s)this.processSkin(this.skins[s]);for(let s=0;s<t.animations.length;++s)this.processAnimation(t.animations[s],e[0]);this._invokeAll(function(s){s.afterParse&&s.afterParse(e)})}_invokeAll(e){for(let t=0,n=this.plugins.length;t<n;t++)e(this.plugins[t])}}class me{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,t){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const n=this.writer,s=n.json,r=n.extensionsUsed,i={};e.name&&(i.name=e.name),i.color=e.color.toArray(),i.intensity=e.intensity,e.isDirectionalLight?i.type="directional":e.isPointLight?(i.type="point",e.distance>0&&(i.range=e.distance)):e.isSpotLight&&(i.type="spot",e.distance>0&&(i.range=e.distance),i.spot={},i.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,i.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(s.extensions=s.extensions||{},s.extensions[this.name]={lights:[]},r[this.name]=!0);const o=s.extensions[this.name].lights;o.push(i),t.extensions=t.extensions||{},t.extensions[this.name]={light:o.length-1}}}class Ee{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,t){if(!e.isMeshBasicMaterial)return;const s=this.writer.extensionsUsed;t.extensions=t.extensions||{},t.extensions[this.name]={},s[this.name]=!0,t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=.9}}class Me{constructor(e){this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(e,t){if(!e.isGLTFSpecularGlossinessMaterial)return;const n=this.writer,s=n.extensionsUsed,r={};t.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=t.pbrMetallicRoughness.baseColorFactor);const i=[1,1,1];if(e.specular.toArray(i,0),r.specularFactor=i,r.glossinessFactor=e.glossiness,t.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=t.pbrMetallicRoughness.baseColorTexture),e.specularMap){const o={index:n.processTexture(e.specularMap)};n.applyTextureTransform(o,e.specularMap),r.specularGlossinessTexture=o}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class we{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const i={index:n.processTexture(e.clearcoatMap)};n.applyTextureTransform(i,e.clearcoatMap),r.clearcoatTexture=i}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const i={index:n.processTexture(e.clearcoatRoughnessMap)};n.applyTextureTransform(i,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=i}if(e.clearcoatNormalMap){const i={index:n.processTexture(e.clearcoatNormalMap)};n.applyTextureTransform(i,e.clearcoatNormalMap),r.clearcoatNormalTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class ye{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const i={index:n.processTexture(e.iridescenceMap)};n.applyTextureTransform(i,e.iridescenceMap),r.iridescenceTexture=i}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const i={index:n.processTexture(e.iridescenceThicknessMap)};n.applyTextureTransform(i,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class Ie{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const i={index:n.processTexture(e.transmissionMap)};n.applyTextureTransform(i,e.transmissionMap),r.transmissionTexture=i}t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}class Ae{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,t){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const n=this.writer,s=n.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const i={index:n.processTexture(e.thicknessMap)};n.applyTextureTransform(i,e.thicknessMap),r.thicknessTexture=i}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),t.extensions=t.extensions||{},t.extensions[this.name]=r,s[this.name]=!0}}Y.Utils={insertKeyframe:function(c,e){const n=c.getValueSize(),s=new c.TimeBufferType(c.times.length+1),r=new c.ValueBufferType(c.values.length+n),i=c.createInterpolant(new c.ValueBufferType(n));let o;if(c.times.length===0){s[0]=e;for(let a=0;a<n;a++)r[a]=0;o=0}else if(e<c.times[0]){if(Math.abs(c.times[0]-e)<.001)return 0;s[0]=e,s.set(c.times,1),r.set(i.evaluate(e),0),r.set(c.values,n),o=0}else if(e>c.times[c.times.length-1]){if(Math.abs(c.times[c.times.length-1]-e)<.001)return c.times.length-1;s[s.length-1]=e,s.set(c.times,0),r.set(c.values,0),r.set(i.evaluate(e),c.values.length),o=s.length-1}else for(let a=0;a<c.times.length;a++){if(Math.abs(c.times[a]-e)<.001)return a;if(c.times[a]<e&&c.times[a+1]>e){s.set(c.times.slice(0,a+1),0),s[a+1]=e,s.set(c.times.slice(a+1),a+2),r.set(c.values.slice(0,(a+1)*n),0),r.set(i.evaluate(e),(a+1)*n),r.set(c.values.slice((a+1)*n),(a+2)*n),o=a+1;break}}return c.times=s,c.values=r,o},mergeMorphTargetTracks:function(c,e){const t=[],n={},s=c.tracks;for(let r=0;r<s.length;++r){let i=s[r];const o=v.parseTrackName(i.name),a=v.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){t.push(i);continue}if(i.createInterpolant!==i.InterpolantFactoryMethodDiscrete&&i.createInterpolant!==i.InterpolantFactoryMethodLinear){if(i.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),i=i.clone(),i.setInterpolation(ee)}const f=a.morphTargetInfluences.length,h=a.morphTargetDictionary[o.propertyIndex];if(h===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let l;if(n[a.uuid]===void 0){l=i.clone();const u=new l.ValueBufferType(f*l.times.length);for(let d=0;d<l.times.length;d++)u[d*f+h]=l.values[d];l.name=(o.nodeName||"")+".morphTargetInfluences",l.values=u,n[a.uuid]=l,t.push(l);continue}const x=i.createInterpolant(new i.ValueBufferType(1));l=n[a.uuid];for(let u=0;u<l.times.length;u++)l.values[u*f+h]=x.evaluate(l.times[u]);for(let u=0;u<i.times.length;u++){const d=this.insertKeyframe(l,i.times[u]);l.values[d*f+h]=i.values[u]}}return c.tracks=t,c}};export{Y as GLTFExporter};
