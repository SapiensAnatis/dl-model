import{ak as D,av as W,aw as X,ax as J,ay as q,az as F,aA as Z,aB as U,aC as $,aD as Q,aE as B,aF as ee,ar as te,aG as se,aH as ne,aq as ie,aI as re,aJ as oe,aK as ae,aL as ce,aM as le,aN as ue}from"./index.7054238d.js";class j{constructor(){this.pluginCallbacks=[],this.register(function(e){return new Ee(e)}),this.register(function(e){return new Me(e)}),this.register(function(e){return new we(e)}),this.register(function(e){return new Ae(e)}),this.register(function(e){return new Re(e)}),this.register(function(e){return new ye(e)}),this.register(function(e){return new Ie(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,s,i,t){typeof i=="object"&&(console.warn("THREE.GLTFExporter: parse() expects options as the fourth argument now."),t=i);const r=new me,n=[];for(let o=0,a=this.pluginCallbacks.length;o<a;o++)n.push(this.pluginCallbacks[o](r));r.setPlugins(n),r.write(e,s,t).catch(i)}parseAsync(e,s){const i=this;return new Promise(function(t,r){i.parse(e,t,r,s)})}}const x={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123,FLOAT:5126,UNSIGNED_INT:5125,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},A={};A[te]=x.NEAREST;A[se]=x.NEAREST_MIPMAP_NEAREST;A[ne]=x.NEAREST_MIPMAP_LINEAR;A[ie]=x.LINEAR;A[re]=x.LINEAR_MIPMAP_NEAREST;A[oe]=x.LINEAR_MIPMAP_LINEAR;A[ae]=x.CLAMP_TO_EDGE;A[ce]=x.REPEAT;A[le]=x.MIRRORED_REPEAT;const P={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},k=12,fe=1179937895,he=2,z=8,pe=1313821514,de=5130562;function L(c,e){return c.length===e.length&&c.every(function(s,i){return s===e[i]})}function ge(c){return new TextEncoder().encode(c).buffer}function xe(c){return L(c.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function Te(c,e,s){const i={min:new Array(c.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(c.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let t=e;t<e+s;t++)for(let r=0;r<c.itemSize;r++){let n;c.itemSize>4?n=c.array[t*c.itemSize+r]:r===0?n=c.getX(t):r===1?n=c.getY(t):r===2?n=c.getZ(t):r===3&&(n=c.getW(t)),i.min[r]=Math.min(i.min[r],n),i.max[r]=Math.max(i.max[r],n)}return i}function Y(c){return Math.ceil(c/4)*4}function G(c,e=0){const s=Y(c.byteLength);if(s!==c.byteLength){const i=new Uint8Array(s);if(i.set(new Uint8Array(c)),e!==0)for(let t=c.byteLength;t<s;t++)i[t]=e;return i.buffer}return c}function H(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function V(c,e){if(c.toBlob!==void 0)return new Promise(i=>c.toBlob(i,e));let s;return e==="image/jpeg"?s=.92:e==="image/webp"&&(s=.8),c.convertToBlob({type:e,quality:s})}class me{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter"}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map}}setPlugins(e){this.plugins=e}async write(e,s,i){this.options=Object.assign({},{binary:!1,trs:!1,onlyVisible:!0,truncateDrawRange:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},i),this.options.animations.length>0&&(this.options.trs=!0),this.processInput(e),await Promise.all(this.pending);const t=this,r=t.buffers,n=t.json;i=t.options;const o=t.extensionsUsed,a=new Blob(r,{type:"application/octet-stream"}),l=Object.keys(o);if(l.length>0&&(n.extensionsUsed=l),n.buffers&&n.buffers.length>0&&(n.buffers[0].byteLength=a.size),i.binary===!0){const p=new FileReader;p.readAsArrayBuffer(a),p.onloadend=function(){const u=G(p.result),T=new DataView(new ArrayBuffer(z));T.setUint32(0,u.byteLength,!0),T.setUint32(4,de,!0);const f=G(ge(JSON.stringify(n)),32),h=new DataView(new ArrayBuffer(z));h.setUint32(0,f.byteLength,!0),h.setUint32(4,pe,!0);const d=new ArrayBuffer(k),E=new DataView(d);E.setUint32(0,fe,!0),E.setUint32(4,he,!0);const m=k+h.byteLength+f.byteLength+T.byteLength+u.byteLength;E.setUint32(8,m,!0);const S=new Blob([d,h,f,T,u],{type:"application/octet-stream"}),g=new FileReader;g.readAsArrayBuffer(S),g.onloadend=function(){s(g.result)}}}else if(n.buffers&&n.buffers.length>0){const p=new FileReader;p.readAsDataURL(a),p.onloadend=function(){const u=p.result;n.buffers[0].uri=u,s(n)}}else s(n)}serializeUserData(e,s){if(Object.keys(e.userData).length===0)return;const i=this.options,t=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(i.includeCustomExtensions&&r.gltfExtensions){s.extensions===void 0&&(s.extensions={});for(const n in r.gltfExtensions)s.extensions[n]=r.gltfExtensions[n],t[n]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(s.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,s=!1){if(this.uids.has(e)===!1){const t=new Map;t.set(!0,this.uid++),t.set(!1,this.uid++),this.uids.set(e,t)}return this.uids.get(e).get(s)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const i=new D;for(let t=0,r=e.count;t<r;t++)if(Math.abs(i.fromBufferAttribute(e,t).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const s=this.cache;if(s.attributesNormalized.has(e))return s.attributesNormalized.get(e);const i=e.clone(),t=new D;for(let r=0,n=i.count;r<n;r++)t.fromBufferAttribute(i,r),t.x===0&&t.y===0&&t.z===0?t.setX(1):t.normalize(),i.setXYZ(r,t.x,t.y,t.z);return s.attributesNormalized.set(e,i),i}applyTextureTransform(e,s){let i=!1;const t={};(s.offset.x!==0||s.offset.y!==0)&&(t.offset=s.offset.toArray(),i=!0),s.rotation!==0&&(t.rotation=s.rotation,i=!0),(s.repeat.x!==1||s.repeat.y!==1)&&(t.scale=s.repeat.toArray(),i=!0),i&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=t,this.extensionsUsed.KHR_texture_transform=!0)}buildMetalRoughTexture(e,s){if(e===s)return e;function i(f){return f.encoding===ue?function(d){return d<.04045?d*.0773993808:Math.pow(d*.9478672986+.0521327014,2.4)}:function(d){return d}}console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures.");const t=e==null?void 0:e.image,r=s==null?void 0:s.image,n=Math.max((t==null?void 0:t.width)||0,(r==null?void 0:r.width)||0),o=Math.max((t==null?void 0:t.height)||0,(r==null?void 0:r.height)||0),a=H();a.width=n,a.height=o;const l=a.getContext("2d");l.fillStyle="#00ffff",l.fillRect(0,0,n,o);const p=l.getImageData(0,0,n,o);if(t){l.drawImage(t,0,0,n,o);const f=i(e),h=l.getImageData(0,0,n,o).data;for(let d=2;d<h.length;d+=4)p.data[d]=f(h[d]/256)*256}if(r){l.drawImage(r,0,0,n,o);const f=i(s),h=l.getImageData(0,0,n,o).data;for(let d=1;d<h.length;d+=4)p.data[d]=f(h[d]/256)*256}l.putImageData(p,0,0);const T=(e||s).clone();return T.source=new W(a),T.encoding=X,T}processBuffer(e){const s=this.json,i=this.buffers;return s.buffers||(s.buffers=[{byteLength:0}]),i.push(e),0}processBufferView(e,s,i,t,r){const n=this.json;n.bufferViews||(n.bufferViews=[]);let o;s===x.UNSIGNED_BYTE?o=1:s===x.UNSIGNED_SHORT?o=2:o=4;const a=Y(t*e.itemSize*o),l=new DataView(new ArrayBuffer(a));let p=0;for(let f=i;f<i+t;f++)for(let h=0;h<e.itemSize;h++){let d;e.itemSize>4?d=e.array[f*e.itemSize+h]:h===0?d=e.getX(f):h===1?d=e.getY(f):h===2?d=e.getZ(f):h===3&&(d=e.getW(f)),s===x.FLOAT?l.setFloat32(p,d,!0):s===x.UNSIGNED_INT?l.setUint32(p,d,!0):s===x.UNSIGNED_SHORT?l.setUint16(p,d,!0):s===x.UNSIGNED_BYTE&&l.setUint8(p,d),p+=o}const u={buffer:this.processBuffer(l.buffer),byteOffset:this.byteOffset,byteLength:a};return r!==void 0&&(u.target=r),r===x.ARRAY_BUFFER&&(u.byteStride=e.itemSize*o),this.byteOffset+=a,n.bufferViews.push(u),{id:n.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const s=this,i=s.json;return i.bufferViews||(i.bufferViews=[]),new Promise(function(t){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const n=G(r.result),o={buffer:s.processBuffer(n),byteOffset:s.byteOffset,byteLength:n.byteLength};s.byteOffset+=n.byteLength,t(i.bufferViews.push(o)-1)}})}processAccessor(e,s,i,t){const r=this.options,n=this.json,o={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",16:"MAT4"};let a;if(e.array.constructor===Float32Array)a=x.FLOAT;else if(e.array.constructor===Uint32Array)a=x.UNSIGNED_INT;else if(e.array.constructor===Uint16Array)a=x.UNSIGNED_SHORT;else if(e.array.constructor===Uint8Array)a=x.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type.");if(i===void 0&&(i=0),t===void 0&&(t=e.count),r.truncateDrawRange&&s!==void 0&&s.index===null){const f=i+t,h=s.drawRange.count===1/0?e.count:s.drawRange.start+s.drawRange.count;i=Math.max(i,s.drawRange.start),t=Math.min(f,h)-i,t<0&&(t=0)}if(t===0)return null;const l=Te(e,i,t);let p;s!==void 0&&(p=e===s.index?x.ELEMENT_ARRAY_BUFFER:x.ARRAY_BUFFER);const u=this.processBufferView(e,a,i,t,p),T={bufferView:u.id,byteOffset:u.byteOffset,componentType:a,count:t,max:l.max,min:l.min,type:o[e.itemSize]};return e.normalized===!0&&(T.normalized=!0),n.accessors||(n.accessors=[]),n.accessors.push(T)-1}processImage(e,s,i,t="image/png"){const r=this,n=r.cache,o=r.json,a=r.options,l=r.pending;n.images.has(e)||n.images.set(e,{});const p=n.images.get(e),u=t+":flipY/"+i.toString();if(p[u]!==void 0)return p[u];o.images||(o.images=[]);const T={mimeType:t},f=H();f.width=Math.min(e.width,a.maxTextureSize),f.height=Math.min(e.height,a.maxTextureSize);const h=f.getContext("2d");if(i===!0&&(h.translate(0,f.height),h.scale(1,-1)),e.data!==void 0){s!==J&&console.error("GLTFExporter: Only RGBAFormat is supported."),(e.width>a.maxTextureSize||e.height>a.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const E=new Uint8ClampedArray(e.height*e.width*4);for(let m=0;m<E.length;m+=4)E[m+0]=e.data[m+0],E[m+1]=e.data[m+1],E[m+2]=e.data[m+2],E[m+3]=e.data[m+3];h.putImageData(new ImageData(E,e.width,e.height),0,0)}else h.drawImage(e,0,0,f.width,f.height);a.binary===!0?l.push(V(f,t).then(E=>r.processBufferViewImage(E)).then(E=>{T.bufferView=E})):f.toDataURL!==void 0?T.uri=f.toDataURL(t):l.push(V(f,t).then(E=>new FileReader().readAsDataURL(E)).then(E=>{T.uri=E}));const d=o.images.push(T)-1;return p[u]=d,d}processSampler(e){const s=this.json;s.samplers||(s.samplers=[]);const i={magFilter:A[e.magFilter],minFilter:A[e.minFilter],wrapS:A[e.wrapS],wrapT:A[e.wrapT]};return s.samplers.push(i)-1}processTexture(e){const s=this.cache,i=this.json;if(s.textures.has(e))return s.textures.get(e);i.textures||(i.textures=[]);let t=e.userData.mimeType;t==="image/webp"&&(t="image/png");const r={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,t)};e.name&&(r.name=e.name),this._invokeAll(function(o){o.writeTexture&&o.writeTexture(e,r)});const n=i.textures.push(r)-1;return s.textures.set(e,n),n}processMaterial(e){const s=this.cache,i=this.json;if(s.materials.has(e))return s.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;i.materials||(i.materials=[]);const t={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(L(r,[1,1,1,1])||(t.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(t.pbrMetallicRoughness.metallicFactor=e.metalness,t.pbrMetallicRoughness.roughnessFactor=e.roughness):(t.pbrMetallicRoughness.metallicFactor=.5,t.pbrMetallicRoughness.roughnessFactor=.5),e.metalnessMap||e.roughnessMap){const o=this.buildMetalRoughTexture(e.metalnessMap,e.roughnessMap),a={index:this.processTexture(o)};this.applyTextureTransform(a,o),t.pbrMetallicRoughness.metallicRoughnessTexture=a}if(e.map){const o={index:this.processTexture(e.map)};this.applyTextureTransform(o,e.map),t.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive.clone().multiplyScalar(e.emissiveIntensity),a=Math.max(o.r,o.g,o.b);if(a>1&&(o.multiplyScalar(1/a),console.warn("THREE.GLTFExporter: Some emissive components exceed 1; emissive has been limited")),a>0&&(t.emissiveFactor=o.toArray()),e.emissiveMap){const l={index:this.processTexture(e.emissiveMap)};this.applyTextureTransform(l,e.emissiveMap),t.emissiveTexture=l}}if(e.normalMap){const o={index:this.processTexture(e.normalMap)};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),t.normalTexture=o}if(e.aoMap){const o={index:this.processTexture(e.aoMap),texCoord:1};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),t.occlusionTexture=o}e.transparent?t.alphaMode="BLEND":e.alphaTest>0&&(t.alphaMode="MASK",t.alphaCutoff=e.alphaTest),e.side===q&&(t.doubleSided=!0),e.name!==""&&(t.name=e.name),this.serializeUserData(e,t),this._invokeAll(function(o){o.writeMaterial&&o.writeMaterial(e,t)});const n=i.materials.push(t)-1;return s.materials.set(e,n),n}processMesh(e){const s=this.cache,i=this.json,t=[e.geometry.uuid];if(Array.isArray(e.material))for(let g=0,M=e.material.length;g<M;g++)t.push(e.material[g].uuid);else t.push(e.material.uuid);const r=t.join(":");if(s.meshes.has(r))return s.meshes.get(r);const n=e.geometry;let o;if(e.isLineSegments?o=x.LINES:e.isLineLoop?o=x.LINE_LOOP:e.isLine?o=x.LINE_STRIP:e.isPoints?o=x.POINTS:o=e.material.wireframe?x.LINES:x.TRIANGLES,n.isBufferGeometry!==!0)throw new Error("THREE.GLTFExporter: Geometry is not of type THREE.BufferGeometry.");const a={},l={},p=[],u=[],T={uv:"TEXCOORD_0",uv2:"TEXCOORD_1",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},f=n.getAttribute("normal");f!==void 0&&!this.isNormalizedNormalAttribute(f)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),n.setAttribute("normal",this.createNormalizedNormalAttribute(f)));let h=null;for(let g in n.attributes){if(g.slice(0,5)==="morph")continue;const M=n.attributes[g];if(g=T[g]||g.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(g)||(g="_"+g),s.attributes.has(this.getUID(M))){l[g]=s.attributes.get(this.getUID(M));continue}h=null;const w=M.array;g==="JOINTS_0"&&!(w instanceof Uint16Array)&&!(w instanceof Uint8Array)&&(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),h=new F(new Uint16Array(w),M.itemSize,M.normalized));const I=this.processAccessor(h||M,n);I!==null&&(l[g]=I,s.attributes.set(this.getUID(M),I))}if(f!==void 0&&n.setAttribute("normal",f),Object.keys(l).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const g=[],M=[],y={};if(e.morphTargetDictionary!==void 0)for(const w in e.morphTargetDictionary)y[e.morphTargetDictionary[w]]=w;for(let w=0;w<e.morphTargetInfluences.length;++w){const I={};let C=!1;for(const b in n.morphAttributes){if(b!=="position"&&b!=="normal"){C||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),C=!0);continue}const N=n.morphAttributes[b][w],v=b.toUpperCase(),_=n.attributes[b];if(s.attributes.has(this.getUID(N,!0))){I[v]=s.attributes.get(this.getUID(N,!0));continue}const O=N.clone();if(!n.morphTargetsRelative)for(let R=0,K=N.count;R<K;R++)O.setXYZ(R,N.getX(R)-_.getX(R),N.getY(R)-_.getY(R),N.getZ(R)-_.getZ(R));I[v]=this.processAccessor(O,n),s.attributes.set(this.getUID(_,!0),I[v])}u.push(I),g.push(e.morphTargetInfluences[w]),e.morphTargetDictionary!==void 0&&M.push(y[w])}a.weights=g,M.length>0&&(a.extras={},a.extras.targetNames=M)}const d=Array.isArray(e.material);if(d&&n.groups.length===0)return null;const E=d?e.material:[e.material],m=d?n.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let g=0,M=m.length;g<M;g++){const y={mode:o,attributes:l};if(this.serializeUserData(n,y),u.length>0&&(y.targets=u),n.index!==null){let I=this.getUID(n.index);(m[g].start!==void 0||m[g].count!==void 0)&&(I+=":"+m[g].start+":"+m[g].count),s.attributes.has(I)?y.indices=s.attributes.get(I):(y.indices=this.processAccessor(n.index,n,m[g].start,m[g].count),s.attributes.set(I,y.indices)),y.indices===null&&delete y.indices}const w=this.processMaterial(E[m[g].materialIndex]);w!==null&&(y.material=w),p.push(y)}a.primitives=p,i.meshes||(i.meshes=[]),this._invokeAll(function(g){g.writeMesh&&g.writeMesh(e,a)});const S=i.meshes.push(a)-1;return s.meshes.set(r,S),S}processCamera(e){const s=this.json;s.cameras||(s.cameras=[]);const i=e.isOrthographicCamera,t={type:i?"orthographic":"perspective"};return i?t.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:t.perspective={aspectRatio:e.aspect,yfov:Z.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(t.name=e.type),s.cameras.push(t)-1}processAnimation(e,s){const i=this.json,t=this.nodeMap;i.animations||(i.animations=[]),e=j.Utils.mergeMorphTargetTracks(e.clone(),s);const r=e.tracks,n=[],o=[];for(let a=0;a<r.length;++a){const l=r[a],p=U.parseTrackName(l.name);let u=U.findNode(s,p.nodeName);const T=P[p.propertyName];if(p.objectName==="bones"&&(u.isSkinnedMesh===!0?u=u.skeleton.getBoneByName(p.objectIndex):u=void 0),!u||!T)return console.warn('THREE.GLTFExporter: Could not export animation track "%s".',l.name),null;const f=1;let h=l.values.length/l.times.length;T===P.morphTargetInfluences&&(h/=u.morphTargetInfluences.length);let d;l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(d="CUBICSPLINE",h/=3):l.getInterpolation()===$?d="STEP":d="LINEAR",o.push({input:this.processAccessor(new F(l.times,f)),output:this.processAccessor(new F(l.values,h)),interpolation:d}),n.push({sampler:o.length-1,target:{node:t.get(u),path:T}})}return i.animations.push({name:e.name||"clip_"+i.animations.length,samplers:o,channels:n}),i.animations.length-1}processSkin(e){const s=this.json,i=this.nodeMap,t=s.nodes[i.get(e)],r=e.skeleton;if(r===void 0)return null;const n=e.skeleton.bones[0];if(n===void 0)return null;const o=[],a=new Float32Array(r.bones.length*16),l=new Q;for(let u=0;u<r.bones.length;++u)o.push(i.get(r.bones[u])),l.copy(r.boneInverses[u]),l.multiply(e.bindMatrix).toArray(a,u*16);return s.skins===void 0&&(s.skins=[]),s.skins.push({inverseBindMatrices:this.processAccessor(new F(a,16)),joints:o,skeleton:i.get(n)}),t.skin=s.skins.length-1}processNode(e){const s=this.json,i=this.options,t=this.nodeMap;s.nodes||(s.nodes=[]);const r={};if(i.trs){const o=e.quaternion.toArray(),a=e.position.toArray(),l=e.scale.toArray();L(o,[0,0,0,1])||(r.rotation=o),L(a,[0,0,0])||(r.translation=a),L(l,[1,1,1])||(r.scale=l)}else e.matrixAutoUpdate&&e.updateMatrix(),xe(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const o=this.processMesh(e);o!==null&&(r.mesh=o)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const o=[];for(let a=0,l=e.children.length;a<l;a++){const p=e.children[a];if(p.visible||i.onlyVisible===!1){const u=this.processNode(p);u!==null&&o.push(u)}}o.length>0&&(r.children=o)}this._invokeAll(function(o){o.writeNode&&o.writeNode(e,r)});const n=s.nodes.push(r)-1;return t.set(e,n),n}processScene(e){const s=this.json,i=this.options;s.scenes||(s.scenes=[],s.scene=0);const t={};e.name!==""&&(t.name=e.name),s.scenes.push(t);const r=[];for(let n=0,o=e.children.length;n<o;n++){const a=e.children[n];if(a.visible||i.onlyVisible===!1){const l=this.processNode(a);l!==null&&r.push(l)}}r.length>0&&(t.nodes=r),this.serializeUserData(e,t)}processObjects(e){const s=new B;s.name="AuxScene";for(let i=0;i<e.length;i++)s.children.push(e[i]);this.processScene(s)}processInput(e){const s=this.options;e=e instanceof Array?e:[e],this._invokeAll(function(t){t.beforeParse&&t.beforeParse(e)});const i=[];for(let t=0;t<e.length;t++)e[t]instanceof B?this.processScene(e[t]):i.push(e[t]);i.length>0&&this.processObjects(i);for(let t=0;t<this.skins.length;++t)this.processSkin(this.skins[t]);for(let t=0;t<s.animations.length;++t)this.processAnimation(s.animations[t],e[0]);this._invokeAll(function(t){t.afterParse&&t.afterParse(e)})}_invokeAll(e){for(let s=0,i=this.plugins.length;s<i;s++)e(this.plugins[s])}}class Ee{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,s){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const i=this.writer,t=i.json,r=i.extensionsUsed,n={};e.name&&(n.name=e.name),n.color=e.color.toArray(),n.intensity=e.intensity,e.isDirectionalLight?n.type="directional":e.isPointLight?(n.type="point",e.distance>0&&(n.range=e.distance)):e.isSpotLight&&(n.type="spot",e.distance>0&&(n.range=e.distance),n.spot={},n.spot.innerConeAngle=(e.penumbra-1)*e.angle*-1,n.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(t.extensions=t.extensions||{},t.extensions[this.name]={lights:[]},r[this.name]=!0);const o=t.extensions[this.name].lights;o.push(n),s.extensions=s.extensions||{},s.extensions[this.name]={light:o.length-1}}}class Me{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}writeMaterial(e,s){if(!e.isMeshBasicMaterial)return;const t=this.writer.extensionsUsed;s.extensions=s.extensions||{},s.extensions[this.name]={},t[this.name]=!0,s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=.9}}class we{constructor(e){this.writer=e,this.name="KHR_materials_pbrSpecularGlossiness"}writeMaterial(e,s){if(!e.isGLTFSpecularGlossinessMaterial)return;const i=this.writer,t=i.extensionsUsed,r={};s.pbrMetallicRoughness.baseColorFactor&&(r.diffuseFactor=s.pbrMetallicRoughness.baseColorFactor);const n=[1,1,1];if(e.specular.toArray(n,0),r.specularFactor=n,r.glossinessFactor=e.glossiness,s.pbrMetallicRoughness.baseColorTexture&&(r.diffuseTexture=s.pbrMetallicRoughness.baseColorTexture),e.specularMap){const o={index:i.processTexture(e.specularMap)};i.applyTextureTransform(o,e.specularMap),r.specularGlossinessTexture=o}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ye{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const n={index:i.processTexture(e.clearcoatMap)};i.applyTextureTransform(n,e.clearcoatMap),r.clearcoatTexture=n}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const n={index:i.processTexture(e.clearcoatRoughnessMap)};i.applyTextureTransform(n,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=n}if(e.clearcoatNormalMap){const n={index:i.processTexture(e.clearcoatNormalMap)};i.applyTextureTransform(n,e.clearcoatNormalMap),r.clearcoatNormalTexture=n}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ie{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const n={index:i.processTexture(e.iridescenceMap)};i.applyTextureTransform(n,e.iridescenceMap),r.iridescenceTexture=n}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const n={index:i.processTexture(e.iridescenceThicknessMap)};i.applyTextureTransform(n,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=n}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ae{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const n={index:i.processTexture(e.transmissionMap)};i.applyTextureTransform(n,e.transmissionMap),r.transmissionTexture=n}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Re{constructor(e){this.writer=e,this.name="KHR_materials_volume"}writeMaterial(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const n={index:i.processTexture(e.thicknessMap)};i.applyTextureTransform(n,e.thicknessMap),r.thicknessTexture=n}r.attenuationDistance=e.attenuationDistance,r.attenuationColor=e.attenuationColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}j.Utils={insertKeyframe:function(c,e){const i=c.getValueSize(),t=new c.TimeBufferType(c.times.length+1),r=new c.ValueBufferType(c.values.length+i),n=c.createInterpolant(new c.ValueBufferType(i));let o;if(c.times.length===0){t[0]=e;for(let a=0;a<i;a++)r[a]=0;o=0}else if(e<c.times[0]){if(Math.abs(c.times[0]-e)<.001)return 0;t[0]=e,t.set(c.times,1),r.set(n.evaluate(e),0),r.set(c.values,i),o=0}else if(e>c.times[c.times.length-1]){if(Math.abs(c.times[c.times.length-1]-e)<.001)return c.times.length-1;t[t.length-1]=e,t.set(c.times,0),r.set(c.values,0),r.set(n.evaluate(e),c.values.length),o=t.length-1}else for(let a=0;a<c.times.length;a++){if(Math.abs(c.times[a]-e)<.001)return a;if(c.times[a]<e&&c.times[a+1]>e){t.set(c.times.slice(0,a+1),0),t[a+1]=e,t.set(c.times.slice(a+1),a+2),r.set(c.values.slice(0,(a+1)*i),0),r.set(n.evaluate(e),(a+1)*i),r.set(c.values.slice((a+1)*i),(a+2)*i),o=a+1;break}}return c.times=t,c.values=r,o},mergeMorphTargetTracks:function(c,e){const s=[],i={},t=c.tracks;for(let r=0;r<t.length;++r){let n=t[r];const o=U.parseTrackName(n.name),a=U.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){s.push(n);continue}if(n.createInterpolant!==n.InterpolantFactoryMethodDiscrete&&n.createInterpolant!==n.InterpolantFactoryMethodLinear){if(n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),n=n.clone(),n.setInterpolation(ee)}const l=a.morphTargetInfluences.length,p=a.morphTargetDictionary[o.propertyIndex];if(p===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let u;if(i[a.uuid]===void 0){u=n.clone();const f=new u.ValueBufferType(l*u.times.length);for(let h=0;h<u.times.length;h++)f[h*l+p]=u.values[h];u.name=(o.nodeName||"")+".morphTargetInfluences",u.values=f,i[a.uuid]=u,s.push(u);continue}const T=n.createInterpolant(new n.ValueBufferType(1));u=i[a.uuid];for(let f=0;f<u.times.length;f++)u.values[f*l+p]=T.evaluate(u.times[f]);for(let f=0;f<n.times.length;f++){const h=this.insertKeyframe(u,n.times[f]);u.values[h*l+p]=n.values[f]}}return c.tracks=s,c}};export{j as GLTFExporter};
